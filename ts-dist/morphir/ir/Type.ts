// Generated by morphir-elm

import { Morphir_IR_AccessControlled_AccessControlled } from "../../morphir/ir/AccessControlled"
import { Morphir_IR_FQName_FQName } from "../../morphir/ir/FQName"
import { Morphir_IR_Name_Name } from "../../morphir/ir/Name"
import { Morphir_IR_Type_Constructors } from "../../morphir/ir/Type"
import { Morphir_IR_Type_Field } from "../../morphir/ir/Type"
import { Morphir_IR_Type_Type } from "../../morphir/ir/Type"

/* Constructors in a dictionary keyed by their name. The values are the argument types for each constructor.
*/
export type Morphir_IR_Type_Constructors<a> = Array<[Morphir_IR_Name_Name, Array<[Morphir_IR_Name_Name, Morphir_IR_Type_Type<a>]>]>

/* This syntax represents a type definition. For example:

  - `type alias Foo a = {bar : Maybe a, qux : Int}`
  - `type MyList a = End | Cons a (MyList a)`

In the definition, the `List Name` refers to type parameters on the LHS
and `Type extra` refers to the RHS

*/
export type Morphir_IR_Type_Definition<a> = CustomTypeDefinition<a> | TypeAliasDefinition<a>

interface Morphir_IR_Type_CustomTypeDefinition<a>{
  kind: "CustomTypeDefinition";
  arg1: Array<Morphir_IR_Name_Name>;
  arg2: Morphir_IR_AccessControlled_AccessControlled<Morphir_IR_Type_Constructors<a>>;
}

interface Morphir_IR_Type_TypeAliasDefinition<a>{
  kind: "TypeAliasDefinition";
  arg1: Array<Morphir_IR_Name_Name>;
  arg2: Morphir_IR_Type_Type<a>;
}

/* An opaque representation of a field. It's made up of a name and a type.
*/
export type Morphir_IR_Type_Field<a> = {
  Name: Morphir_IR_Name_Name;
  Tpe: Morphir_IR_Type_Type<a>;
}

/* */
export type Morphir_IR_Type_Specification<a> = CustomTypeSpecification<a> | OpaqueTypeSpecification<a> | TypeAliasSpecification<a>

interface Morphir_IR_Type_CustomTypeSpecification<a>{
  kind: "CustomTypeSpecification";
  arg1: Array<Morphir_IR_Name_Name>;
  arg2: Morphir_IR_Type_Constructors<a>;
}

interface Morphir_IR_Type_OpaqueTypeSpecification<a>{
  kind: "OpaqueTypeSpecification";
  arg1: Array<Morphir_IR_Name_Name>;
}

interface Morphir_IR_Type_TypeAliasSpecification<a>{
  kind: "TypeAliasSpecification";
  arg1: Array<Morphir_IR_Name_Name>;
  arg2: Morphir_IR_Type_Type<a>;
}

/* Represents a type expression that can appear in various places within the IR. It can be the right-hand-side of
a type alias declaration, input and output types of a function or as an annotation on values after type inference is
done.

Type are modeled as expression trees: a recursive data structure with various node types. The type argument `a` allows
us to assign some additional attributes to each node in the tree. Here are some details on each node type in the tree:

  - **Variable**
      - Represents a type variable.
      - It has a single argument which captures the name of the variable.
      - [Wikipedia: Type variable](https://en.wikipedia.org/wiki/Type_variable)
      - [creation](#variable), [matching](#matchVariable)
  - **Reference**
      - A fully-qualified reference to some other type or type alias within the package or one of its dependencies.
      - References to built-in types (like `Int`, `String`, ...) don't have an associated definition.
      - [creation](#reference), [matching](#matchReference)
  - **Tuple**
      - A tuple is a composition of other types (potentially other tuples).
      - The order of types is relevant so the easiest way to think about it is as a list of types.
      - A tuple can have any number of elements and there is no restriction on the element types.
      - A tuple with zero elements is equivalent with `Unit`.
      - A tuple with a single element is equivalent to the element type itself.
      - [Wikipedia: Tuple](https://en.wikipedia.org/wiki/Tuple)
      - [creation](#tuple), [matching](#matchTuple)
  - **Record**
      - A record is a composition of other types like tuples but types are identified by a field name instead of an index.
      - The best way to think of a record is as a dictionary of types.
      - Our representation captures the order of fields for convenience but the order should not be considered for type
        equivalence.
      - [Wikipedia: Record](https://en.wikipedia.org/wiki/Record_(computer_science))
      - [Elm-lang: Records](https://elm-lang.org/docs/records)
      - Utilities: [creation](#record), [matching](#matchRecord)
  - **ExtensibleRecord**
      - Similar to records but while record types declare that the underlying object has "exactly these fields" an
        extensible record declares that the object has "at least these fields".
      - Besides the list of fields you need to specify a variable name that will be used to abstract over the type
        that's being extended.
      - [Elm: Extensible records](https://ckoster22.medium.com/advanced-types-in-elm-extensible-records-67e9d804030d)
      - [creation](#extensibleRecord), [matching](#matchExtensibleRecord)
  - **Function**
      - Represents the type of a function. The two arguments are the argument and the return type of the function.
      - Multi-argument functions are represented by composing functions:
          - `a -> b -> c` is represented as `a -> (b -> c)`
      - [Wikipedia: Function type](https://en.wikipedia.org/wiki/Function_type)
      - [creation](#function), [matching](#matchFunction)
  - **Unit**
      - Unit type is used as a placeholder in situations where a type is required but the corresponding value is unused.
      - Semantically the unit type represents a set that has exactly one value which is often called unit.
      - Unit corresponds to void in some other programming languages.
      - [Wikipedia: Unit type](https://en.wikipedia.org/wiki/Unit_type)
      - [creation](#unit), [matching](#matchUnit)

*/
export type Morphir_IR_Type_Type<a> = ExtensibleRecord<a> | Function<a> | Record<a> | Reference<a> | Tuple<a> | Unit<a> | Variable<a>

interface Morphir_IR_Type_ExtensibleRecord<a>{
  kind: "ExtensibleRecord";
  arg1: a;
  arg2: Morphir_IR_Name_Name;
  arg3: Array<Morphir_IR_Type_Field<a>>;
}

interface Morphir_IR_Type_Function<a>{
  kind: "Function";
  arg1: a;
  arg2: Morphir_IR_Type_Type<a>;
  arg3: Morphir_IR_Type_Type<a>;
}

interface Morphir_IR_Type_Record<a>{
  kind: "Record";
  arg1: a;
  arg2: Array<Morphir_IR_Type_Field<a>>;
}

interface Morphir_IR_Type_Reference<a>{
  kind: "Reference";
  arg1: a;
  arg2: Morphir_IR_FQName_FQName;
  arg3: Array<Morphir_IR_Type_Type<a>>;
}

interface Morphir_IR_Type_Tuple<a>{
  kind: "Tuple";
  arg1: a;
  arg2: Array<Morphir_IR_Type_Type<a>>;
}

interface Morphir_IR_Type_Unit<a>{
  kind: "Unit";
  arg1: a;
}

interface Morphir_IR_Type_Variable<a>{
  kind: "Variable";
  arg1: a;
  arg2: Morphir_IR_Name_Name;
}
