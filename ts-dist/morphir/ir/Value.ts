// Generated by morphir-elm

import { Morphir_IR_FQName_FQName } from "../../morphir/ir/FQName"
import { Morphir_IR_Literal_Literal } from "../../morphir/ir/Literal"
import { Morphir_IR_Name_Name } from "../../morphir/ir/Name"
import { Morphir_IR_Type_Type } from "../../morphir/ir/Type"
import { Morphir_IR_Value_Definition } from "../../morphir/ir/Value"
import { Morphir_IR_Value_Pattern } from "../../morphir/ir/Value"
import { Morphir_IR_Value_Value } from "../../morphir/ir/Value"

/* Type that represents a value or function definition. A definition is the actual data or logic as opposed to a specification
which is just the specification of those. Value definitions can be typed or untyped. Exposed values have to be typed.
*/
export type Morphir_IR_Value_Definition<ta, va> = {
  InputTypes: Array<[Morphir_IR_Name_Name, va, Morphir_IR_Type_Type<ta>]>;
  OutputType: Morphir_IR_Type_Type<ta>;
  Body: Morphir_IR_Value_Value<ta, va>;
}

/* Type that represents a pattern. A pattern can do two things: match on a specific shape or exact value and extract
parts of a value into variables. It's a recursive data structure made of of the following building blocks:

  - **WildcardPattern**
      - Matches any value and does not extract any variables.
      - `_` in Elm
  - **AsPattern**
      - Assigns a variable name to the value matched by a nested pattern.
      - `(...) as foo` in Elm
      - Special case: when there is just a variable name in a pattern in Elm it will be represented as a
        `WildcardPattern` wrapped in an `AsPattern`
  - **TuplePattern**
      - Matches on a tuple where each element matches the nested patterns.
  - **ConstructorPattern**
      - Matches on a type constructor and its arguments.
  - **EmptyListPattern**
      - Matches on an empty list.
  - **HeadTailPattern**
      - Matches on the head and the tail of a list.
      - Combined with `EmptyListPattern` it can match on lists of any specific sizes.
  - **LiteralPattern**
      - Matches an an exact literal value.
  - **UnitPattern**
      - Matches the `Unit` value only.

*/
export type Morphir_IR_Value_Pattern<a> = AsPattern<a> | ConstructorPattern<a> | EmptyListPattern<a> | HeadTailPattern<a> | LiteralPattern<a> | TuplePattern<a> | UnitPattern<a> | WildcardPattern<a>

interface Morphir_IR_Value_AsPattern<a>{
  kind: "AsPattern";
  arg1: a;
  arg2: Morphir_IR_Value_Pattern<a>;
  arg3: Morphir_IR_Name_Name;
}

interface Morphir_IR_Value_ConstructorPattern<a>{
  kind: "ConstructorPattern";
  arg1: a;
  arg2: Morphir_IR_FQName_FQName;
  arg3: Array<Morphir_IR_Value_Pattern<a>>;
}

interface Morphir_IR_Value_EmptyListPattern<a>{
  kind: "EmptyListPattern";
  arg1: a;
}

interface Morphir_IR_Value_HeadTailPattern<a>{
  kind: "HeadTailPattern";
  arg1: a;
  arg2: Morphir_IR_Value_Pattern<a>;
  arg3: Morphir_IR_Value_Pattern<a>;
}

interface Morphir_IR_Value_LiteralPattern<a>{
  kind: "LiteralPattern";
  arg1: a;
  arg2: Morphir_IR_Literal_Literal;
}

interface Morphir_IR_Value_TuplePattern<a>{
  kind: "TuplePattern";
  arg1: a;
  arg2: Array<Morphir_IR_Value_Pattern<a>>;
}

interface Morphir_IR_Value_UnitPattern<a>{
  kind: "UnitPattern";
  arg1: a;
}

interface Morphir_IR_Value_WildcardPattern<a>{
  kind: "WildcardPattern";
  arg1: a;
}

/* A value without any additional information.
*/
export type Morphir_IR_Value_RawValue = Morphir_IR_Value_Value<[], []>

/* Type that represents a value or function specification. The specification of what the value or function
is without the actual data or logic behind it.
*/
export type Morphir_IR_Value_Specification<ta> = {
  Inputs: Array<[Morphir_IR_Name_Name, Morphir_IR_Type_Type<ta>]>;
  Output: Morphir_IR_Type_Type<ta>;
}

/* A value with type information.
*/
export type Morphir_IR_Value_TypedValue = Morphir_IR_Value_Value<[], Morphir_IR_Type_Type<[]>>

/* Type that represents a value expression. This is a recursive data structure with various node types representing
each possible language construct.

The extra type parameters `ta` and `va` allow you to add type and value attributes. Type attributes allow you to add
extra information to each type node. Value attributes do the same for value nodes. In many cases you might not need this
in which case you can just put a unit (`()`) type or a type variable as a placeholder.

These are the supported node types:

  - **Literal**
      - Represents a literal value like 13, True or "foo".
      - See the documentation in the [Literal](Morphir-IR-Literal) module for details on the supported literal types.
      - See [Wikipedia: Literal](https://en.wikipedia.org/wiki/Literal_(computer_programming)) for more details on
        literals.
  - **Constructor**
      - Reference to a custom type constructor name.
      - If the type constructor has arguments this node will be wrapped into some `Apply` nodes depending on the number
        of arguments.
  - **Tuple**
      - Represents a tuple value.
      - Each element of the tuple is in turn a `Value`.
  - **List**
      - Represents a list of values.
      - Each item of the list is in turn a `Value`.
  - **Record**
      - Represents a record value.
      - Each field value of the record is in turn a `Value`.
  - **Variable**
      - Reference to a variable.
  - **Reference**
      - Reference to another value within or outside the module.
      - References are always full-qualified to make resolution easier.
  - **Field**
      - Represents accessing a field on a record together with the target expression.
      - This is done using the dot notation in Elm: `foo.bar`
  - **FieldFunction**
      - Represents accessing a field on a record without the target expression.
      - This is a shortcut to refer to the function that extracts the field from the input.
      - This is done using the dot notation in Elm without a target expression: `.bar`
  - **Apply**
      - Represents a function application.
      - The two arguments are the target function and the argument.
      - Multi-argument invocations are expressed by wrapping multiple `Apply` nodes in each other (currying).
  - **Lambda**
      - Represents a lambda abstraction.
      - The first argument is a pattern to match on the input, the second is the lambda expression's body.
  - **LetDefinition**
      - Represents a single let binding.
      - Multiple let bindings are achieved through wrapping multiple let expressions into each other.
  - **LetRecursion**
      - Special let binding that allows mutual recursion between the bindings.
      - This is necessary because `LetDefinition` will not make recursion possible due to its scoping rules.
  - **Destructure**
      - Applies a pattern match to the first expression and passes any extracted variables to the second expression.
      - This can be represented as a let expression with a pattern binding or a single-case pattern-match in Elm.
  - **IfThenElse**
      - Represents a simple if/then/else expression.
      - The 3 arguments are: the condition, the then branch and the else branch.
  - **PatternMatch**
      - Represents a pattern-match.
  - **UpdateRecord**
      - Expression to update one or more fields of a record.
      - As usual in FP this is a copy-on-update so no mutation is happening.
  - **Unit**
      - Represents the single value in the Unit type.
      - When you find Unit in the IR it usually means: "There's nothing useful here".

*/
export type Morphir_IR_Value_Value<ta, va> = Apply<ta, va> | Constructor<ta, va> | Destructure<ta, va> | Field<ta, va> | FieldFunction<ta, va> | IfThenElse<ta, va> | Lambda<ta, va> | LetDefinition<ta, va> | LetRecursion<ta, va> | List<ta, va> | Literal<ta, va> | PatternMatch<ta, va> | Record<ta, va> | Reference<ta, va> | Tuple<ta, va> | Unit<ta, va> | UpdateRecord<ta, va> | Variable<ta, va>

interface Morphir_IR_Value_Apply<ta, va>{
  kind: "Apply";
  arg1: va;
  arg2: Morphir_IR_Value_Value<ta, va>;
  arg3: Morphir_IR_Value_Value<ta, va>;
}

interface Morphir_IR_Value_Constructor<ta, va>{
  kind: "Constructor";
  arg1: va;
  arg2: Morphir_IR_FQName_FQName;
}

interface Morphir_IR_Value_Destructure<ta, va>{
  kind: "Destructure";
  arg1: va;
  arg2: Morphir_IR_Value_Pattern<va>;
  arg3: Morphir_IR_Value_Value<ta, va>;
  arg4: Morphir_IR_Value_Value<ta, va>;
}

interface Morphir_IR_Value_Field<ta, va>{
  kind: "Field";
  arg1: va;
  arg2: Morphir_IR_Value_Value<ta, va>;
  arg3: Morphir_IR_Name_Name;
}

interface Morphir_IR_Value_FieldFunction<ta, va>{
  kind: "FieldFunction";
  arg1: va;
  arg2: Morphir_IR_Name_Name;
}

interface Morphir_IR_Value_IfThenElse<ta, va>{
  kind: "IfThenElse";
  arg1: va;
  arg2: Morphir_IR_Value_Value<ta, va>;
  arg3: Morphir_IR_Value_Value<ta, va>;
  arg4: Morphir_IR_Value_Value<ta, va>;
}

interface Morphir_IR_Value_Lambda<ta, va>{
  kind: "Lambda";
  arg1: va;
  arg2: Morphir_IR_Value_Pattern<va>;
  arg3: Morphir_IR_Value_Value<ta, va>;
}

interface Morphir_IR_Value_LetDefinition<ta, va>{
  kind: "LetDefinition";
  arg1: va;
  arg2: Morphir_IR_Name_Name;
  arg3: Morphir_IR_Value_Definition<ta, va>;
  arg4: Morphir_IR_Value_Value<ta, va>;
}

interface Morphir_IR_Value_LetRecursion<ta, va>{
  kind: "LetRecursion";
  arg1: va;
  arg2: Array<[Morphir_IR_Name_Name, Morphir_IR_Value_Definition<ta, va>]>;
  arg3: Morphir_IR_Value_Value<ta, va>;
}

interface Morphir_IR_Value_List<ta, va>{
  kind: "List";
  arg1: va;
  arg2: Array<Morphir_IR_Value_Value<ta, va>>;
}

interface Morphir_IR_Value_Literal<ta, va>{
  kind: "Literal";
  arg1: va;
  arg2: Morphir_IR_Literal_Literal;
}

interface Morphir_IR_Value_PatternMatch<ta, va>{
  kind: "PatternMatch";
  arg1: va;
  arg2: Morphir_IR_Value_Value<ta, va>;
  arg3: Array<[Morphir_IR_Value_Pattern<va>, Morphir_IR_Value_Value<ta, va>]>;
}

interface Morphir_IR_Value_Record<ta, va>{
  kind: "Record";
  arg1: va;
  arg2: Array<[Morphir_IR_Name_Name, Morphir_IR_Value_Value<ta, va>]>;
}

interface Morphir_IR_Value_Reference<ta, va>{
  kind: "Reference";
  arg1: va;
  arg2: Morphir_IR_FQName_FQName;
}

interface Morphir_IR_Value_Tuple<ta, va>{
  kind: "Tuple";
  arg1: va;
  arg2: Array<Morphir_IR_Value_Value<ta, va>>;
}

interface Morphir_IR_Value_Unit<ta, va>{
  kind: "Unit";
  arg1: va;
}

interface Morphir_IR_Value_UpdateRecord<ta, va>{
  kind: "UpdateRecord";
  arg1: va;
  arg2: Morphir_IR_Value_Value<ta, va>;
  arg3: Array<[Morphir_IR_Name_Name, Morphir_IR_Value_Value<ta, va>]>;
}

interface Morphir_IR_Value_Variable<ta, va>{
  kind: "Variable";
  arg1: va;
  arg2: Morphir_IR_Name_Name;
}
