module Morphir.TypeScript.PrettyPrinter exposing (mapCompilationUnit)

{-| This module contains a pretty-printer that takes a TypeScript AST as an input and returns a formatted text
representation.

-}

import Morphir.File.SourceCode exposing (Doc, concat, indentLines, newLine)
import Morphir.IR.Path exposing (Path)
import Morphir.TypeScript.AST exposing (CompilationUnit, Declaration(..), Expression(..), FunctionScope(..), ImportDetails, Parameter, Privacy(..), Statement(..), TypeExp(..))
import Morphir.TypeScript.NamespacePath exposing (namespaceNameFromPackageAndModule)
import Morphir.TypeScript.PrettyPrinter.Expressions exposing (..)


{-| Indent used in pretty printer. Note that we post-process the output with
Prettier (<https://prettier.io/>) so changing this value won't affect the
generated output.
-}
defaultIndent =
    2


{-| -}
mapCompilationUnit : CompilationUnit -> Doc
mapCompilationUnit cu =
    case cu of
        { dirPath, body } ->
            concat
                [ "// Generated by morphir-elm"
                , newLine ++ newLine
                , body
                    |> List.map mapStatement
                    |> String.join newLine
                ]


mapStatement : Statement -> String
mapStatement statement =
    case statement of
        AssignmentStatement lhsExpression maybeAnnotation rhsExpression ->
            concat
                [ mapExpression lhsExpression
                , mapMaybeAnnotation maybeAnnotation
                , " = "
                , mapExpression rhsExpression
                , ";"
                ]

        DeclarationStatement declaration ->
            mapDeclaration declaration

        LetStatement lhsExpression maybeAnnotation rhsExpression ->
            concat
                [ "let "
                , mapExpression lhsExpression
                , mapMaybeAnnotation maybeAnnotation
                , " = "
                , mapExpression rhsExpression
                , ";"
                ]

        ExpressionStatement expression ->
            concat [ mapExpression expression, ";" ]

        ReturnStatement expression ->
            concat [ "return ", mapExpression expression, ";" ]


mapMaybeDeclaration : Maybe Declaration -> String
mapMaybeDeclaration maybeDeclaration =
    case maybeDeclaration of
        Just declaration ->
            mapDeclaration declaration

        Nothing ->
            ""


mapDeclaration: Declaration -> Doc
mapDeclaration declaration =
    case declaration of
        ClassDeclaration { name, privacy, variables, body, constructor } ->
            let
                preface : String
                preface =
                    concat
                        [ privacy |> exportIfPublic
                        , "class "
                        , name
                        , mapGenericVariables variables
                        , " {"
                        ]

                mainbody : List String
                mainbody =
                    [ body |> List.map mapStatement >> String.join newLine
                    , newLine
                    , mapMaybeDeclaration constructor
                    ]
            in
            concat
                [ preface
                , newLine
                , mainbody |> indentLines defaultIndent
                , "}"
                , newLine
                ]

        FunctionDeclaration { name, scope, parameters, body, privacy } ->
            let
                prefaceKeywords : String
                prefaceKeywords =
                    case scope of
                        ModuleFunction ->
                            concat
                                [ privacy |> exportIfPublic
                                , "function "
                                ]

                        ClassStaticFunction ->
                            concat
                                [ "static "
                                ]

                        _ ->
                            ""
            in
            concat
                [ prefaceKeywords
                , name
                , "("
                , String.join ", " (parameters |> List.map mapParameter)
                , ") {"
                , newLine
                , body |> List.map mapStatement |> indentLines defaultIndent
                , newLine
                , "}"
                ]

        ImportDeclaration details ->
            mapImportDeclaration details

        ImportAliasDeclaration { name, privacy, namespacePath } ->
            concat
                [ privacy |> exportIfPublic
                , "import "
                , name
                , " = "
                , namespaceNameFromPackageAndModule (Tuple.first namespacePath) (Tuple.second namespacePath)
                ]

        NamespaceDeclaration { name, privacy, body } ->
            concat
                [ privacy |> exportIfPublic
                , "namespace "
                , name
                , " {" ++ newLine
                , body
                    |> List.map mapStatement
                    |> List.map (\mappedTypeDef -> mappedTypeDef ++ newLine)
                    |> indentLines defaultIndent
                , newLine ++ "}"
                ]

        TypeAliasDeclaration { name, privacy, doc, variables, typeExpression } ->
            let
                docstring =
                    if String.length doc > 0 then
                        String.concat [ "/*", doc, "*/" ]

                    else
                        ""
            in
            concat
                [ docstring
                , newLine
                , privacy |> exportIfPublic
                , "type "
                , name
                , mapGenericVariables variables
                , " = "
                , mapTypeExp typeExpression
                ]



mapImportDeclaration : ImportDetails -> String
mapImportDeclaration { importClause, moduleSpecifier } =
    concat
        [ "import "
        , importClause
        , " from "
        , "\"" ++ moduleSpecifier ++ "\""
        ]


exportIfPublic : Privacy -> String
exportIfPublic privacy =
    case privacy of
        Public ->
            "export "

        Private ->
            ""


mapExpression : Expression -> String
mapExpression expression =
    case expression of
        ArrayLiteralExpression values ->
            concat
                [ "["
                , String.join ", " (values |> List.map mapExpression)
                , "]"
                ]

        CallExpression { function, arguments } ->
            concat
                [ mapExpression function
                , "("
                , String.join ", " (arguments |> List.map mapExpression)
                , ")"
                ]

        Identifier name ->
            name

        MemberExpression { object, member } ->
            concat
                [ mapExpression object
                , "."
                , mapExpression member
                ]

        NewExpression { constructor, arguments } ->
            concat
                [ "new "
                , constructor
                , "("
                , arguments |> List.map mapExpression |> String.join ", "
                , ")"
                ]

        NullLiteral ->
            "null"

        ObjectLiteralExpression { properties } ->
            let
                mapObjectField : ( String, Expression ) -> String
                mapObjectField ( fieldName, fieldValue ) =
                    concat
                        [ fieldName
                        , ": "
                        , fieldValue |> mapExpression
                        ]
            in
            concat
                [ "{"
                , String.join ", " (properties |> List.map mapObjectField)
                , "}"
                ]

        StringLiteralExpression string ->
            concat
                [ "\""
                , string
                , "\""
                ]


mapParameter : Parameter -> String
mapParameter { modifiers, name, typeAnnotation } =
    concat
        [ modifiers |> String.join " "
        , " "
        , name
        , mapMaybeAnnotation typeAnnotation
        ]


mapMaybeAnnotation : Maybe TypeExp -> String
mapMaybeAnnotation maybeTypeExp =
    case maybeTypeExp of
        Nothing ->
            ""

        Just typeExp ->
            ": " ++ mapTypeExp typeExp
