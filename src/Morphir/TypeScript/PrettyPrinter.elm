module Morphir.TypeScript.PrettyPrinter exposing
    ( Options, mapCompilationUnit, mapTypeDef, mapTypeExp
    , mapObjectExp
    )

{-| This module contains a pretty-printer that takes a TypeScript AST as an input and returns a formatted text
representation.

@docs Options, mapCompilationUnit, mapTypeDef, mapTypeExp

-}

import Elm.Syntax.ModuleName exposing (ModuleName)
import Morphir.File.SourceCode exposing (Doc, concat, empty, indentLines, newLine)
import Morphir.IR.FQName as FQName exposing (FQName, fQName)
import Morphir.IR.Name as Name exposing (Name)
import Morphir.IR.Path as Path exposing (Path)
import Morphir.TypeScript.AST exposing (CompilationUnit, ObjectExp, Privacy(..), TypeDef(..), TypeExp(..))


{-| Formatting options.
-}
type alias Options =
    { indentDepth : Int
    }


namePrefixFromPackageAndModule : Path -> Path -> String
namePrefixFromPackageAndModule packagePath modulePath =
    concat
        [ packagePath |> Path.toString Name.toTitleCase "_"
        , "_"
        , modulePath |> Path.toString Name.toTitleCase "_"
        , "_"
        ]


{-| -}
mapCompilationUnit : Options -> CompilationUnit -> Doc
mapCompilationUnit opt cu =
    case cu of
        { dirPath, fileName, packagePath, modulePath, typeDefs } ->
            let
                namePrefix =
                    namePrefixFromPackageAndModule packagePath modulePath
            in
            concat
                [ "// Generated by morphir-elm"
                , newLine ++ newLine
                , typeDefs
                    |> List.map (mapTypeDef opt namePrefix)
                    |> String.join (newLine ++ newLine)
                , newLine
                ]


{-| Map a type definition to text.
-}
mapGenericVariables : Options -> String -> List TypeExp -> String
mapGenericVariables opt namePrefix variables =
    case List.length variables of
        0 ->
            ""

        _ ->
            concat
                [ "<"
                , String.join ", " (variables |> List.map (mapTypeExp opt namePrefix))
                , ">"
                ]


mapTypeDef : Options -> String -> TypeDef -> Doc
mapTypeDef opt namePrefix typeDef =
    let
        exportIfPublic : Privacy -> String
        exportIfPublic privacy =
            case privacy of
                Public ->
                    "export "

                Private ->
                    ""
    in
    case typeDef of
        TypeAlias { name, privacy, doc, variables, typeExpression } ->
            let
                docstring =
                    if String.length doc > 0 then
                        String.concat [ "/*", doc, "*/" ]

                    else
                        ""
            in
            concat
                [ docstring
                , newLine
                , privacy |> exportIfPublic
                , "type "
                , namePrefix
                , name |> Name.toTitleCase
                , mapGenericVariables opt namePrefix variables
                , " = "
                , mapTypeExp opt namePrefix typeExpression
                ]

        Interface { name, privacy, variables, fields } ->
            concat
                [ privacy |> exportIfPublic
                , "interface "
                , namePrefix
                , name |> Name.toTitleCase
                , mapGenericVariables opt namePrefix variables
                , mapObjectExp opt namePrefix fields
                ]


{-| Map an object expression or interface definiton to text
-}
mapObjectExp : Options -> String -> ObjectExp -> Doc
mapObjectExp opt namePrefix objectExp =
    let
        mapField : ( String, TypeExp ) -> Doc
        mapField ( fieldName, fieldType ) =
            concat [ fieldName, ": ", mapTypeExp opt namePrefix fieldType, ";" ]
    in
    concat
        [ "{"
        , newLine
        , objectExp
            |> List.map mapField
            |> indentLines opt.indentDepth
        , newLine
        , "}"
        ]


{-| Map a type expression to text.
-}
mapTypeExp : Options -> String -> TypeExp -> Doc
mapTypeExp opt namePrefix typeExp =
    case typeExp of
        Any ->
            "any"

        Boolean ->
            "boolean"

        List listType ->
            "Array<" ++ mapTypeExp opt namePrefix listType ++ ">"

        LiteralString stringval ->
            "\"" ++ stringval ++ "\""

        Number ->
            "number"

        Object fieldList ->
            mapObjectExp opt namePrefix fieldList

        String ->
            "string"

        Tuple tupleTypesList ->
            concat
                [ "["
                , tupleTypesList
                    |> List.map (mapTypeExp opt namePrefix)
                    |> String.join ", "
                , "]"
                ]

        TypeRef fQName variables ->
            let
                processed_name : String
                processed_name =
                    case fQName of
                        ( [], [], localName ) ->
                            concat
                                [ namePrefix
                                , localName |> Name.toTitleCase
                                ]

                        ( packagePath, modulePath, localName ) ->
                            concat
                                [ namePrefixFromPackageAndModule packagePath modulePath
                                , localName |> Name.toTitleCase
                                ]
            in
            concat
                [ processed_name
                , mapGenericVariables opt namePrefix variables
                ]

        Union types ->
            types |> List.map (mapTypeExp opt namePrefix) |> String.join " | "

        Variable name ->
            name

        UnhandledType tpe ->
            concat
                [ "any"
                , " /* Unhandled type: "
                , tpe
                , " */"
                ]
